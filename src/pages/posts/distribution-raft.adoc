= Raft 基本流程(草稿)
notfound <notfound@notfound.cn>
1.0, 2023-02-07: init

:page-slug: distribution-raft
:page-category: distribution

== 领导者选举

服务器在三种状态间转换：

[source,plantuml]
----
@startuml
[*] -> Follower
Follower -> Candidate: 心跳超时\n开始选举
Follower <- Candidate: 收到来自领导者的 RPC
Candidate -> Leader: 投票过半\n赢得选举
Leader -> Follower: 更大任期请求
Leader -> [*]
@enduml
----

系统正常运行时，只有一个领导者，其余都是追随者。

=== 正常情况

[source,plantuml]
----
@startuml
participant C as c
participant S1 as s1
participant S2 as s2
participant S3 as s3

s1 -> s1 : wait timeout(1)
activate s1
note right s1
    <font color=red>state=Candidate
    <font color=red>currentTerm=1
    <font color=red>votedFor=1
end note

s1 -> s2 : RequestVote(Term=1, CandidateID=1)
activate s2
note right s2
    state=Follower
    <font color=red>currentTerm=1
    <font color=red>votedFor=1
end note

s1 -> s3 : RequestVote(Term=1, CandidateID=1)
activate s3
note right s3
    state=Follower
    <font color=red>currentTerm=1
    <font color=red>votedFor=1
end note

s1 <-- s2: (Term=1, VoteGranted=true)
deactivate s2

note right s1
    <font color=red>state=Leader
    <font color=red>currentTerm=1
    <font color=red>votedFor=1
end note
s1 <-- s3: (Term=1, VoteGranted=true)
deactivate s3

s1 -> s2 : AppendEntries()
activate s2
s1 -> s3 : AppendEntries()
activate s3
s1 <-- s2
deactivate s2
s1 <-- s3
deactivate s3
deactivate s1
@enduml
----
1. 追随状态节点 S1 未收到任期更大的 RPC 请求，认为集群中没有领导者，进入候选状态；
2. S1 节点开始竞选；
3. S1 获得超过半数投票，成为领导者；
4. 领导者 S1 周期性的发送心跳包，保持领导者的权威。

=== 追随者网络分区

追随者网络波动未及时收到领导者的心跳，会发起新一轮投票。

[source,plantuml]
----
@startuml
participant C as c
participant S1 as s1
participant S2 as s2
participant S3 as s3

activate s1
note right s1
    state=Leader
    currentTerm=1
    votedFor=1
end note
s1 -> s2 : AppendEntries()
activate s2
note right s2
    state=Follower
    currentTerm=1
    votedFor=1
end note
s1 -x s3 : AppendEntries()
note right s3
    state=Follower
    currentTerm=1
    votedFor=1
end note
s1 <-- s2
deactivate s2
deactivate s1

s3 -> s3 : wait timeout(1)
activate s3
note right s3
    <font color=red>state=Candidate
    <font color=red>currentTerm=2
    <font color=red>votedFor=2
end note

s3 -> s2 : RequestVote(Term=2, CandidateID=3)
activate s2
note right s2
    state=Follower
    <font color=red>currentTerm=2
    <font color=red>votedFor=2
end note
s3 -x s1 : RequestVote(Term=2, CandidateID=3)
s3 <-- s2
deactivate s2
note right s3
    <font color=red>state=Leader
    <font color=red>currentTerm=2
    <font color=red>votedFor=2
end note

s3 -> s2 : AppendEntries()
activate s2
s3 -> s1 : AppendEntries()
activate s1
note right s1
    <font color=red>state=Follower
    <font color=red>currentTerm=2
    <font color=red>votedFor=2
end note
s3 <-- s2
deactivate s2
s3 <-- s1
deactivate s1
@enduml
----
1. 由于网络波动 S3 未收到 S1 的心跳包；
2. S3 等待心跳超时，于是 S3 发起新一轮的投票。但此时 S1 并未故障且为领导者；
3. S2 和 S3 投票通过，S3 被当选为新的领导者。 S1 由于网络故障，未收到 S1 发送的投票请求，状态依旧为领导者；
4. S1 收到 S3 发送的心跳，S1 被迫下台，修改状态为追随者。

极端情况，假设 S1 只能发送消息，无法接收消息和响应：

1. S1 为领导者，S2、S3 为追随者；
2. S3 无法收到领导者 S1 发送的心跳，于是发起新一轮的投票；
3. S3 竞选领导导致 S1 下台，但 S3 没有收到响应，无法得知自己的发起的投票已经通过，因此不会向其他节点发送心跳；
4. S1 等待心跳超时，发起新一轮的投票并成功当选领导；
5. 再次进入步骤 2

=== 领导者网络分区

TODO

== 日志复制

=== 正常情况

[source,plantuml]
----
@startuml
participant C as c
participant S1 as s1
participant S2 as s2
participant S3 as s3

activate c
c -> s1 : send(a)
activate s1
note right s1
    state=Leader
    currentTerm=1
    LeaderCommit=0
end note
s1 -> s1 : AppendEntries()

s1 -> s2 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=0, PrevLogTerm=0, Entries=[], LeaderCommit=0)
note right s2
    state=Follower
    currentTerm=1
    LeaderCommit=0
    <font color=red>log[1]=a
end note
activate s2

s1 -> s3 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=0, PrevLogTerm=0, Entries=[], LeaderCommit=0)
activate s3
note right s3
    state=Follower
    currentTerm=1
    LeaderCommit=0
    <font color=red>log[1]=a
end note
s1 <-- s2 : (Term=1, Success=true)
deactivate s2

note right s1
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=1
end note
c <-- s1
s1 <-- s3 : (Term=1, Success=true)
deactivate s3
deactivate s1


c -> s1 : send(b)
activate s1
s1 -> s1 : AppendEntries()
s1 -> s2 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=0, PrevLogTerm=0, Entries=[], LeaderCommit=0)
activate s2
note right s2
    state=Follower
    currentTerm=1
    <font color=red>LeaderCommit=1
end note

s1 -> s3 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=0, PrevLogTerm=0, Entries=[], LeaderCommit=0)
activate s3
note right s3
    state=Follower
    currentTerm=1
    <font color=red>LeaderCommit=1
end note
s1 <-- s2 : (Term=1, Success=true)
deactivate s2
note right s1
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=2
end note
s1 <-- s3 : (Term=1, Success=true)
deactivate s3
c <-- s1
deactivate s1

c -> s1 : send(c)
activate s1
s1 -> s1 : AppendEntries()
s1 -> s2 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=2, PrevLogTerm=1, LeaderCommit=2)
activate s2
note right s2
    state=Follower
    currentTerm=1
    <font color=red>LeaderCommit=2
end note

s1 -> s3 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=2, PrevLogTerm=1, LeaderCommit=2)
activate s3
note right s3
    state=Follower
    currentTerm=1
    <font color=red>LeaderCommit=2
end note
s1 <-- s2 : (Term=1, Success=true)
deactivate s2
note right s1
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=3
end note
s1 <-- s3 : (Term=1, Success=true)
deactivate s3
c <-- s1
deactivate s1
deactivate c
@enduml
----

=== 追随者网络分区

[source,plantuml]
----
@startuml
participant C as c
participant S1 as s1
participant S2 as s2
participant S3 as s3

c -> s1 : send(d)
activate s1
s1 -> s1 : AppendEntries()
s1 -> s2 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=3, PrevLogTerm=1, LeaderCommit=3)
activate s2
note right s2
    state=Follower
    currentTerm=1
    <font color=red>LeaderCommit=3
end note
s1 <-- s2 : (Term=1, Success=true)
deactivate s2
c <-- s1
deactivate s1
note right s1
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=4
end note

c -> s1 : send(e)
activate s1
s1 -> s1 : AppendEntries()
s1 -> s2 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=4, PrevLogTerm=1, LeaderCommit=4)
activate s2
note right s2
    state=Follower
    currentTerm=1
    <font color=red>LeaderCommit=4
end note
s1 <-- s2 : (Term=1, Success=true)
deactivate s2
c <-- s1
deactivate s1
note right s1
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=5
end note

c -> s1 : send(f)
activate s1
s1 -> s1 : AppendEntries()
s1 -> s2 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=5, PrevLogTerm=1, LeaderCommit=5)
activate s2
note right s2
    state=Follower
    currentTerm=1
    <font color=red>LeaderCommit=5
end note
s1 <-- s2 : (Term=1, Success=true)
deactivate s2
c <-- s1
note right s1
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=6
end note

s1 -> s3 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=5, PrevLogTerm=1, LeaderCommit=6)
activate s3
s1 <-- s3 : (Term=1, Success=false)
deactivate s3
s1 -> s3 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=4, PrevLogTerm=1, LeaderCommit=6)
activate s3
s1 <-- s3 : (Term=1, Success=false)
deactivate s3
s1 -> s3 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=3, PrevLogTerm=1, LeaderCommit=6)
activate s3
note right s3
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=4
end note
s1 <-- s3 : (Term=1, Success=true)
deactivate s3

s1 -> s3 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=4, PrevLogTerm=1, LeaderCommit=6)
activate s3
note right s3
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=5
end note
s1 <-- s3 : (Term=1, Success=true)
deactivate s3

s1 -> s3 : AppendEntries(Term=1, LeaderID=1, PrevLogIndex=5, PrevLogTerm=1, LeaderCommit=6)
activate s3
note right s3
    state=Leader
    currentTerm=1
    <font color=red>LeaderCommit=6
end note
s1 <-- s3 : (Term=1, Success=true)
deactivate s3

deactivate s1

@enduml
----

=== 领导者网络分区

TODO

== 参考

* https://book.douban.com/subject/35794814/[《深入理解分布式系统》]
* https://raft.github.io/
* https://zhuanlan.zhihu.com/p/32052223
