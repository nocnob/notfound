= caddy
notfound <notfound@notfound.cn>
1.0, 2023-03-17: init

:page-slug: caddy
:page-category: caddy
:page-draft: true

== 单个域名

=== 单个域名，使用已有证书

link:/posts/linux-ssl-nginx/[生成自签名证书]，然后执行：

[source,bash]
----
mkdir -p /srv/caddy/certs/demo.com
# 私钥
cp demo.com/demo.com.key /srv/caddy/certs/demo.com/
# 域名证书和二级根证书放到同一个文件
cat demo.com/demo.com.crt ca2.demo.com/cacert.pem  > /srv/caddy/certs/demo.com/demo.com.crt
----

caddy 配置：

./srv/caddy/Caddyfile
[source,Caddyfile]
----
{
	admin off # <1>
	ocsp_stapling off # <2>
}

demo.com {
	tls /srv/caddy/certs/demo.com/demo.com.crt /srv/caddy/certs/demo.com/demo.com.key # <3>

	root * /srv/caddy/html/demo.com # <4>
	file_server # <4>
}
----
<1> 禁用 管理页面
<2> 禁用 OCSP stapling。OCSP 在线证书状态协议，用来验证证书是否有效。OCSP stapling 由 caddy 服务验证证书是否有效
<3> 设置证书和私有文件路径
<4> 静态文件以及文件根路径

只有一个域名且设置了证书相关文件，不会启用自动化证书管理功能。

=== 单个域名，多个子域名，泛域名证书

[source,bash]
----
cp demo.io/demo.io.key /srv/caddy/certs/demo.io
cat demo.io/demo.io.crt ca2.demo.com/cacert.pem > /srv/caddy/certs/demo.io/demo.io.crt
----

=== 自动申请自签名证书

== check

[source,go]
----
package main

import (
	"fmt"
	"html"
	"log"
	"net/http"
	"strings"
)

func main() {
	http.HandleFunc("/check", func(w http.ResponseWriter, r *http.Request) {
		domain := r.URL.Query().Get("domain")
		log.Printf("path=%s,domain=%s", html.EscapeString(r.URL.Path), domain)
		if strings.HasSuffix(domain, ".git.io") {
			fmt.Fprintf(w, "%s ok", domain)
		} else {
			w.WriteHeader(http.StatusForbidden)
		}
	})

	log.Fatal(http.ListenAndServe(":5555", nil))
}
----

==

[source,Caddyfile]
----
{
	http_port 80
	https_port 443
	storage file_system /srv/caddy/storage
	on_demand_tls {
		ask http://localhost:5555/check
		interval 300ms
		burst 3
	}
}

https:// {
	tls internal {
		on_demand
	}
	root * /srv/caddy/html
	file_server
}
----

== 参考

* https://caddy.community/t/serving-tens-of-thousands-of-domains-over-https-with-caddy/11179
* https://caddyserver.com/docs/caddyfile/concepts
