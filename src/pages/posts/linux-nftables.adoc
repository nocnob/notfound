= Linux nftables 使用(草稿)
notfound <notfound@notfound.cn>
1.0, 2023-03-26: init

:page-slug: linux-nftables
:page-category: linux

* 操作系统: Ubuntu 22.04

`nftables` 框架对数据包进行分类，它是 `iptables`、`ip6tables`、`arptables`、`ebtables` 和 `ipset` 实用程序的后续者。

== 启动

nftables 通过 systemd 管理，配置文件路径 `/etc/nftables.conf`。

[source,bash]
----
# 查看 systemd 配置
systemctl cat nftables.service
# 查看服务状态
systemctl status nftables.service
# 启动服务
sudo systemctl start nftables.service
# 设置服务为开机启动
sudo systemctl enable nftables.service
----

`nftables` 支持 `nft` 命令和 `nftables` 脚本，默认配置文件 `/etc/nftables.conf` 就是一个可执行的 `nftables` 脚本：

./etc/nftables.conf
[source,nft]
----
#!/usr/sbin/nft -f

flush ruleset # <1>

table inet filter { # <2>
	chain input { # <3>
		type filter hook input priority 0; # <4>
	}
	chain forward {
		type filter hook forward priority 0;
	}
	chain output {
		type filter hook output priority 0;
	}
}
----
<1> 清空规则集
<2> 创建表
<3> 创建链

== Netfilter

https://www.netfilter.org/index.html[netfilter] 为 Linux 内核提供了包过滤功能，nftables 是 netfilter 的一部分。

.Netfilter hooks into Linux networking packet flows (https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks[图片来源])
image::/images/nf-hooks.svg[]

.address families
[Attributes]
|===
| 地址族 | 说明

| netdev | 匹配处理入口和出口的数据包
| inet   | 匹配 IPv4 和 IPv6 数据包
| ip     | 仅匹配 IPv4 数据包，默认值
| ip6    | 仅匹配 IPv6 数据包
| bridge | 匹配通过网桥设备的数据包
| arp    | 匹配 IPv4 地址解析协议(ARP)数据包
|===

.hook
[Attributes]
|===
| hook | 地址族 | 描述

| ingress
| ip/ip6/inet/netdev
| 所有进入系统的数据包都由这个钩子处理。它在第 3 层协议处理程序之前被调用，因此在 prerouting hook 之前被调用，并且它可以用于过滤和监管。Ingress 仅适用于 Inet 族（从 Linux 内核 5.10 起）。

| prerouting
| ip/ip6/inet
| 所有进入系统的数据包都由 prerouting hook 处理，在路由过程之前调用。

| input
| ip/ip6/inet/arp
| 传送到本地系统的数据包由 input hook 处理。

| output
| ip/ip6/inet/arp
| 本地进程发送的数据包由 output hook 处理。

| forward
| ip/ip6/inet
| 转发到不同主机的数据包由 forward hook 处理。

| postrouting
| ip/ip6/inet
| 离开系统的所有数据包都由 postrouting hook 处理。

| egress
| netdev
| 所有离开系统的数据包都由这个钩子处理。它在第 3 层协议处理程序之后和 tc engress 之前被调用。它可用于后期过滤和监管。

|===

== 操作

nftables 中的表是一个包含链、规则、集合和其他对象集合的名字空间。

=== 表

创建表的语法如下：

[source,nft]
----
table <table_address_family> <table_name> {
}
----

等同于命令行：

[source,bash]
----
nft add table <table_address_family> <table_name>
----
* `table_address_family` 以下值其中之一: `netdev`, `inet`, `ip`, `ip6`,  `bridge`, `arp`


=== 链

[source,nft]
----
chain <chain_name> {
  type <type> hook <hook> priority <priority>
}
----

等同于：

[source,bash]
----
nft add chain <table_address_family> <table_name> <chain_name> \
	{ type <type> hook <hook> priority <priority> \; policy <policy> \; }
----

参数说明：

.参数 <type>
[Attributes]
|===
| 类型 | 地址族 | Hooks | 描述

| filter
| arp, bridge, ip, ip6 and inet
| all
| 标准链类型

| nat
| ip, ip6, inet
| prerouting, input, output, postrouting               
| 这个类型的链根据连接跟踪条目执行原生地址转换。只有第一个数据包遍历此链类型。

| route
| ip, ip6
| output
| 如果 IP 标头的相关部分已更改，则遍历此链类型的数据包会导致新的路由查找

|===

.参数 <priority>
[Attributes]
|===
| 名称 | 值 | 地址族 | Hooks

| raw       | -300  | ip, ip6, inet              | all
| mangle    | -150  | ip, ip6, inet              | all
.2+| dstnat | -100  | ip, ip6, inet              | prerouting
            | -300  | bridge                     | prerouting
.2+| filter | 0     | ip, ip6, inet, arp, netdev | all
            | -200  | bridge                     | all
| security  | 50    | ip, ip6, inet              | all
.2+| srcnat | 100   | ip, ip6, inet              | postrouting
            | 300   | bridge                     | postrouting
| out       | 100   | bridge                     | output

|===


.参数 <policy>
|===
| policy | 说明

| accept
| 接受

| drop 
| 丢弃

|===

=== 规则

[source,nft]
----
nft add rule <table_address_family> <table_name> <chain_name> <rule>
----

== 示例

=== 备份和恢复

[source,bash]
----
# 显示 nftables 规则集
nft list ruleset
# 备份
nft list ruleset > file.nft
# 恢复
nft -f file.nft
# 清空
nft flush ruleset
----

=== 网络地址转换(NAT)

=== 本地端口转发

将端口 80 上的传入 IPv4 数据包转发到本地系统上的端口 8080。

[source,nft]
----
table ip nat { # <1>
	chain prerouting { # <2>
		type nat hook prerouting priority dstnat; policy accept; # <3>
		tcp dport 80 redirect to :8080 # <4>
	}
}
----
<1> 名为 nat 的表，仅匹配 IPv4 数据包；
<2> 名为 `prerouting` 的链；
<3> 类型 nat，hook 为 prerouting，优先级 dstnat (DNAT)；
<4> 将目标端口为 80 的流量重定向到 8080。

测试：

[source,bash]
----
# 主机 A，服务端
nc -l 172.16.1.16 8080
# 主机 B，客户端
nc -N 172.16.1.16 80
----
* 服务端需要监听外部端口，监听 `127.0.0.1` 时不会生效；
* 需要跨主机发送请求，在主机 A 上请求服务端不会生效。

=== 跨主机端口转发

[source,nft]
----
table ip nat {
	chain postrouting {
		type nat hook postrouting priority srcnat; policy accept;
		oifname "wlp0s20f3" masquerade
	}

	chain prerouting {
		type nat hook prerouting priority dstnat; policy accept;
		iifname "wlp0s20f3" tcp dport { 80, 443 } dnat to 127.0.0.1
	}
}
----

[source,bash]
----
sudo sysctl -w net.ipv4.ip_forward=1
sudo sysctl -w net.ipv4.conf.wlp0s20f3.route_localnet=1
----

=== 禁止容器访问内网
=== 外部请求转发到容器
=== 限速

[source,bash]
----
----

== 参考

* man nft
* https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html/configuring_firewalls_and_packet_filters/getting-started-with-nftables_firewall-packet-filters
* https://wiki.archlinuxcn.org/zh-hans/Nftables
* https://jensd.be/1086/linux/forward-a-tcp-port-to-another-ip-or-port-using-nat-with-nftables
* https://serverfault.com/questions/1021798/how-to-redirect-requests-on-port-80-to-localhost3000-using-nftables
* https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks
* https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes
