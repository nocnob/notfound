{"componentChunkName":"component---src-pages-posts-asciidoc-page-attributes-slug-tsx","path":"/posts/ruby-process-spawn/","result":{"data":{"asciidoc":{"id":"693dfcb7-754a-51c0-8b19-bf6e9ec940a7","html":"<div class=\"sect1\">\n<h2 id=\"_ruby_process_spawn_缓冲区满导致阻塞\"><a class=\"anchor\" href=\"#_ruby_process_spawn_缓冲区满导致阻塞\"></a>Ruby Process.spawn 缓冲区满导致阻塞</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_ruby_process_spawn_阻塞\"><a class=\"anchor\" href=\"#_ruby_process_spawn_阻塞\"></a>Ruby Process.spawn 阻塞</h3>\n<div class=\"paragraph\">\n<p>Ruby 中使用 <code>Process.spawn</code> 和 <code>pipe</code> 时，pipe 缓冲区为 64 KB，如果不及时读取数据，将会发生阻塞。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"># 未超出缓冲区容量\n# cmd = \"bash -c 'for i in {1..6500}; do echo '123456789'; done'\"\n# 超出缓冲区容量\ncmd = \"bash -c 'for i in {1..6600}; do echo '123456789'; done'\"\n\nout_r, out_w = IO.pipe\ncmd_pid = Process.spawn(cmd, :out =&gt; out_w, :err =&gt; out_w)\nout_w.close\n\nProcess.wait(cmd_pid)\nexitstatus = $?.exitstatus\n\nout = out_r.read\nputs \"child: cmd out length = #{out.length}; Exit status: #{exitstatus}\"</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>标准输出缓冲区满，进程无法结束， <code>Process.wait</code> 一直等待</p>\n</li>\n</ul>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_新线程读缓冲区\"><a class=\"anchor\" href=\"#_新线程读缓冲区\"></a>新线程读缓冲区:</h4>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">cmd = \"bash -c 'for i in {1..6600}; do echo '123456789'; done'\"\n\nout_r, out_w = IO.pipe\ncmd_pid = Process.spawn(cmd, :out =&gt; out_w, :err =&gt; out_w)\nout_reader = Thread.new { out_r.read }\nout_w.close\n\nProcess.wait(cmd_pid)\nexitstatus = $?.exitstatus\n\nputs \"child: cmd out length = #{out_reader.value.length}; Exit status: #{exitstatus}\"</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_新线程等待子进程结束\"><a class=\"anchor\" href=\"#_新线程等待子进程结束\"></a>新线程等待子进程结束：</h4>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">Thread.new do\n  Process.wait(cmd_pid)\n  exitstatus = $?.exitstatus\nend</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_ruby_open3_popen3_阻塞\"><a class=\"anchor\" href=\"#_ruby_open3_popen3_阻塞\"></a>Ruby Open3.popen3 阻塞</h3>\n<div class=\"quoteblock\">\n<blockquote>\n<div class=\"paragraph\">\n<p>You should be careful to avoid deadlocks. Since pipes are fixed length\nbuffers, ::popen3(``prog'') \\{|i, o, e, t| o.read } deadlocks if the\nprogram generates too much output on stderr. You should read stdout and\nstderr simultaneously (using threads or IO.select). However, if you\ndon’t need stderr output, you can use ::popen2. If merged stdout and\nstderr output is not a problem, you can use ::popen2e. If you really\nneed stdout and stderr output as separate strings, you can consider\n::capture3.</p>\n</div>\n</blockquote>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">require 'open3'\n\n# 未超出缓冲区容量\n# cmd = \"bash -c 'for i in {1..6500}; do echo '123456789'; done'\"\n# cmd = \"bash -c 'for i in {1..6500}; do echo '123456789' 1&gt;&amp;2; done'\"\n\n# 超出缓冲区容量\n# cmd = \"bash -c 'for i in {1..6600}; do echo '123456789'; done'\"\ncmd = \"bash -c 'for i in {1..6600}; do echo '123456789' 1&gt;&amp;2; done'\"\n\nOpen3.popen3(cmd) do |stdin, stdout, stderr, wait_thr|\n  stdin.close\n  stdout.read\n  stderr.read\n  exit_status = wait_thr.value\nend</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>标准出错缓冲区满，导致子进程阻塞。父进程在 <code>stdout.read</code> 处一直等待</p>\n</li>\n<li>\n<p>如果调换 <code>stdout.read</code> 和 <code>stderr.read</code> 位置，可以将标准出错缓冲区内容读取出来，但如果出现标准输出缓冲区满，问题依旧</p>\n</li>\n<li>\n<p>可以使用两个独立的线程分别读取 <code>stdout</code> 和 <code>stderr</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>换成 <code>Open3.capture3</code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">stdout_str, stderr_str, status = Open3.capture3(cmd)\n\n# capture3 使用了独立的线程读取标准输出和标准出错\n# out_reader = Thread.new { o.read }\n# err_reader = Thread.new { e.read }</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>capture3</code> 使用了独立的线程读取标准输出和标准出错</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_参考\"><a class=\"anchor\" href=\"#_参考\"></a>参考</h3>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://stackoverflow.com/questions/13829830/ruby-process-spawn-stdout-pipe-buffer-size-limit\" class=\"bare\">https://stackoverflow.com/questions/13829830/ruby-process-spawn-stdout-pipe-buffer-size-limit</a></p>\n</li>\n<li>\n<p><a href=\"https://bugs.ruby-lang.org/issues/9082\" class=\"bare\">https://bugs.ruby-lang.org/issues/9082</a></p>\n</li>\n<li>\n<p><a href=\"https://ruby-doc.org/stdlib-2.7.3/libdoc/open3/rdoc/Open3.html#method-c-capture3\" class=\"bare\">https://ruby-doc.org/stdlib-2.7.3/libdoc/open3/rdoc/Open3.html#method-c-capture3</a></p>\n</li>\n<li>\n<p><a href=\"https://ruby-doc.org/stdlib-2.7.3/libdoc/open3/rdoc/Open3.html#method-c-popen3\" class=\"bare\">https://ruby-doc.org/stdlib-2.7.3/libdoc/open3/rdoc/Open3.html#method-c-popen3</a></p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>","document":{"title":"Ruby Process.spawn 缓冲区满导致阻塞"},"pageAttributes":{"slug":"ruby-process-spawn","category":"ruby"},"revision":{"date":"2021-05-13","number":"1.0"}}},"pageContext":{"id":"693dfcb7-754a-51c0-8b19-bf6e9ec940a7","pageAttributes__slug":"ruby-process-spawn","__params":{"pageAttributes__slug":"ruby-process-spawn"}}},"staticQueryHashes":["3143286284"],"slicesMap":{}}