{"componentChunkName":"component---src-pages-posts-asciidoc-page-attributes-slug-tsx","path":"/posts/ruby-unicorn-progress/","result":{"data":{"asciidoc":{"id":"362ece45-1c9d-5dd6-a5e1-815ae0b677ed","html":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>起因，需要在 unicorn master 上开启一个线程定时收集 Ruby 进程运行数据。</p>\n</div>\n<div class=\"paragraph\">\n<p>Unicorn 生命周期中设置了多个回调： <code>after_fork</code>、<code>before_fork</code>、<code>before_exec</code>、<code>after_worker_exit</code> 和 <code>after_worker_ready</code>，需要在合适的时间点创建线程。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_启动重启和终止\"><a class=\"anchor\" href=\"#_启动重启和终止\"></a>启动、重启和终止</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>在 unicorn 配置文件代码中打上日志，就可以知道大致的工作过程：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"># local variable to guard against running a hook multiple times\nrun_once = true\n\nbefore_fork do |server, worker|\n  server.logger.info \"before_fork\"\n\n  if run_once\n    server.logger.info \"before_fork run_once\"\n    # do_something_once_here ...\n    run_once = false # prevent from firing again\n  end\n\n  old_pid = \"#{server.config[:pid]}.oldbin\"\n  if old_pid != server.pid\n    begin\n      sig = (worker.nr + 1) &gt;= server.worker_processes ? :QUIT : :TTOU\n      server.logger.info \"kill #{File.read(old_pid).strip} #{sig}\"\n      Process.kill(sig, File.read(old_pid).to_i)\n    rescue Errno::ENOENT, Errno::ESRCH\n    end\n  end\nend\n\nbefore_exec do |server|\n  server.logger.info \"before_exec\"\nend\n\nafter_fork do |server, worker|\n  server.logger.info \"after_fork\"\nend</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_启动\"><a class=\"anchor\" href=\"#_启动\"></a>启动</h3>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>启动 master</p>\n</li>\n<li>\n<p>执行 before_fork，每个 worker 都会执行一次</p>\n</li>\n<li>\n<p>启动 worker</p>\n</li>\n<li>\n<p>执行 after_fork，每一个 woker 进程都会执行一次</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-text\" data-lang=\"text\">[#25404 master-n] : Refreshing Gem list\n[#25404 master-n] : listening on addr=0.0.0.0:8080 fd=20\n[#25404 master-n] : before_fork\n[#25404 master-n] : before_fork run_once   # 执行一次\n[#25404 master-n] : before_fork\n[#25407 worker-0] : after_fork\n[#25404 master-n] : before_fork\n[#25407 worker-0] : worker=0 ready\n[#25410 worker-1] : after_fork\n[#25410 worker-1] : worker=1 ready\n[#25404 master-n] : master process ready\n[#25413 worker-2] : after_fork\n[#25413 worker-2] : worker=2 ready</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_重启\"><a class=\"anchor\" href=\"#_重启\"></a>重启</h3>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>启动 new master 进程</p>\n</li>\n<li>\n<p>new master 执行 before_exec</p>\n</li>\n<li>\n<p>new master 执行 before_fork，并向 old master 发送 TTOU 信号。创建最后一个 worker 进程前(before_fork)，向 old master 发送 QUIT 信号</p>\n</li>\n<li>\n<p>new worker 执行 after_exec</p>\n</li>\n<li>\n<p>old master 接收到 QUIT 信号后，结束掉 old woker 进程，然后退出</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-text\" data-lang=\"text\">[#25513 master-n] : executing [\"unicorn\", \"-c\", \"config/unicorn.conf.rb\", \"-D\"] # 创建新的 master\n[#25513 master-n] : before_exec\n[#25513 master-n] : inherited addr=0.0.0.0:8080 fd=20\n[#25513 master-n] : Refreshing Gem list\n[#25513 master-n] : before_fork\n[#25513 master-n] : before_fork run_once     # 执行一次\n[#25513 master-n] : kill 25404 TTOU          # 创建 woker 前(before_fork) 向旧的 master 发送 TTOU\n[#25513 master-n] : before_fork\n[#25513 master-n] : kill 25404 TTOU\n[#25524 worker-0] : after_fork\n[#25524 worker-0] : worker=0 ready\n[#25513 master-n] : before_fork\n[#25513 master-n] : kill 25404 QUIT          # 创建最后一个 woker (before_fork)前后向旧的 master 发送 QUIT\n[#25527 worker-1] : after_fork\n[#25527 worker-1] : worker=1 ready\n[#25513 master-n] : master process ready\n[#25530 worker-2] : after_fork\n[#25530 worker-2] : worker=2 ready\n[#25404 master-o] : reaped #&lt;Process::Status: pid 25407 exit 0&gt; worker=0  # 旧的 master 开始清理旧的 woker\n[#25404 master-o] : reaped #&lt;Process::Status: pid 25410 exit 0&gt; worker=1\n[#25404 master-o] : reaped #&lt;Process::Status: pid 25413 exit 0&gt; worker=2\n[#25404 master-o] : master complete                                       # 旧的 master 退出</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>关键点</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>新的 master 和所有的 woker 就绪之后，才会终止旧的进程</p>\n</li>\n<li>\n<p>新的 master 和旧的 master 通过信号通信</p>\n</li>\n<li>\n<p>旧的 master 负责清理旧的 woker，然后退出</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_终止\"><a class=\"anchor\" href=\"#_终止\"></a>终止</h3>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>master 结束掉所有的 worker 进程，然后退出。</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-log\" data-lang=\"log\">[#25513] : reaped #&lt;Process::Status: pid 25524 exit 0&gt; worker=0\n[#25513] : reaped #&lt;Process::Status: pid 25527 exit 0&gt; worker=1\n[#25513] : reaped #&lt;Process::Status: pid 25530 exit 0&gt; worker=2\n[#25513] : master complete</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_master_主要工作\"><a class=\"anchor\" href=\"#_master_主要工作\"></a>master 主要工作</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>master 负责管理子进程，在无限循环中等待信号、以及检查 woker 数量和是否超时，当 woker 数量减少时会创建新的 woker，当 woker 运行超时时会被 kill：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">@sig_queue = []\n@queue_sigs = [:WINCH, :QUIT, :INT, :TERM, :USR1, :USR2, :HUP, :TTIN, :TTOU]\n@queue_sigs.each { |sig| trap(sig) { @sig_queue &lt;&lt; sig } }\n\ndef log(message)\n  puts \"##{Process.pid} #{message}\"\nend\n\ndef master(pid)\n  Process.detach(pid)\n\n  loop do\n    case @sig_queue.shift\n    when nil\n      # 检查 worker 超时\n      # 检查 worker 数量\n      sleep 0.5\n    when :USR1\n      log \"receive :USR1\"\n    when :USR2\n      log \"receive :USR2\"\n    when :TERM\n      log \"receive :TERM\"\n      break\n    end\n  end\n\n  sleep 1\nend\n\ndef worker(ppid)\n  # TODO\nend\n\nppid = Process.pid\n\nif pid = fork\n  master(pid)\nelse\n  worker(ppid)\nend</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://ruby-doc.org/core-2.5.0/Signal.html\">trap</a> 方法可以注册信号处理函数。当信号发生时，会执行 <code>trap</code> 后面的代码块。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_问题线程与进程\"><a class=\"anchor\" href=\"#_问题线程与进程\"></a>问题：线程与进程</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>线程创建后执行 <code>fork</code> 操作，正在执行的线程会是怎样的存在？在 Linux 中并不推荐多线程中使用 fork，充满了不确定性，可参考 <a href=\"https://www.cnblogs.com/liyuan989/p/4279210.html\">谨慎使用多线程中的fork</a>。</p>\n</div>\n<div class=\"paragraph\">\n<p>来段代码，测试几个比较关心的问题：</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>也就是说除了调用 fork 的线程外，其他线程在子进程中``蒸发''了。</p>\n</li>\n<li>\n<p>假设在 fork 之前，一个线程对某个锁进行的 lock 操作，即持有了该锁，然后另外一个线程调用了 fork 创建子进程。可是在子进程中持有那个锁的线程却<code>消失''了，从子进程的角度来看，这个锁被</code>永久''的上锁了，因为它的持有者``蒸发''了。</p>\n</li>\n</ol>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">def log(message )\n  STDERR.puts \"##{Process.pid} #{message}\"\nend\n\nlog(\"parent pid\")\nmutex = Mutex.new\n\nt = Thread.new do\n  mutex.synchronize do\n    log(\"thread mutex start\")\n    sleep 2\n  end\n  log(\"thread mutex end\")\nend\n\nsleep 1 # 让线程先执行\n\nif pid = fork\n  log(\"parent before, alive?: #{t.alive?}, locked: #{mutex.locked?}\" )\n  sleep 2\n  log(\"parent after, alive?: #{t.alive?}, locked: #{mutex.locked?}\" )\nelse\n  # 线程占用 mutex 时，子进程被创建\n  log(\"child before, alive?: #{t.alive?}, locked: #{mutex.locked?}\" )\n  sleep 2\n  log(\"child after, alive?: #{t.alive?}, locked: #{mutex.locked?}\" )\nend\n\nlog(\"done\")\n\nsleep 1</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>输出结果如下(ruby 2.5.1p57 x86_64-linux-gnu)：</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-text\" data-lang=\"text\">#9544 parent pid                                 # 父进程 id\n#9544 thread mutex start                         # 父进程中，线程启动，持有 mutex\n#9544 parent before, alive?: true, locked: true  # 父进程中，mutex 被占用\n#9547 child before, alive?: false, locked: false # 子进程中，mutex 未被占用，线程没有执行\n#9544 thread mutex end                           # 父进程中，线程结束，释放 mutex\n#9544 parent after, alive?: false, locked: false\n#9547 child after, alive?: false, locked: false  # 子进程中，线程依旧没有执行\n#9547 done\n#9544 done</code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>fork 前创建线程，fork 后线程并不会在子进程中继续执行</p>\n</li>\n<li>\n<p>fork 前线程占用了 Mutex，在 fork 后子进程并不会继续占用</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>又产生了新的问题：</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Ruby 中的 Mutex 是否和 Linux 系统中的锁对应呢？ Ruby 中的多线程是否和 Linux 中的多线程对应呢？还是 Ruby 语言本身进行了特殊的处理？</p>\n</li>\n<li>\n<p>如果进程中存在文件的读、写操作，是否会造成死锁？或者调用某些方法是否会造成死锁？</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>如果在 fork 时线程持有了锁， fork 之后，子进程中的线程不会执行，锁也就无法释放，此时如果子进程尝试获取锁就会一直等待。(上面的示例并没有出现这种情况，原因未知)</p>\n</div>\n<div class=\"paragraph\">\n<p>当前需求是在 master 进程中执行监控线程。woker 进程不需要执行线程以及占用相同的锁，发生上述问题也不会产生不良影响。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_结论\"><a class=\"anchor\" href=\"#_结论\"></a>结论</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p>大部分时间 master 都是比较清闲的</p>\n</li>\n<li>\n<p>可以考虑在 <code>befork_fork</code> 回调里 <code>run_once</code> 启动一个单独的线程进行监控数据收集</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_参考\"><a class=\"anchor\" href=\"#_参考\"></a>参考</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://yhbt.net/unicorn/\">unicorn</a></p>\n</li>\n<li>\n<p><a href=\"https://ruby-doc.org/core-2.5.0/Signal.html\">Signal</a></p>\n</li>\n<li>\n<p><code>man 7 signal</code></p>\n</li>\n<li>\n<p><a href=\"https://www.cnblogs.com/liyuan989/p/4279210.html\">谨慎使用多线程中的fork</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.codingnow.com/2011/01/fork_multi_thread.html\">极不和谐的 fork 多线程程序</a></p>\n</li>\n</ul>\n</div>\n</div>\n</div>","document":{"title":"Unicorn 启动、重启和终止"},"pageAttributes":{"slug":"ruby-unicorn-progress","category":"ruby"},"revision":{"date":"2020-05-15","number":"1.0"}}},"pageContext":{"id":"362ece45-1c9d-5dd6-a5e1-815ae0b677ed","pageAttributes__slug":"ruby-unicorn-progress","__params":{"pageAttributes__slug":"ruby-unicorn-progress"}}},"staticQueryHashes":["3143286284"],"slicesMap":{}}